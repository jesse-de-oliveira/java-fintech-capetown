═══════════════════════════════════════════════════════════
WEEK 3 - DAY 1 - POSTGRESQL SETUP + CONNECTION
Monday Feb 16, 2026
═══════════════════════════════════════════════════════════

WHY DATABASES?
- In-memory storage (Week 2): Data lost on restart.
- Database storage (Week 3): Data persists forever.

WHAT IS POSTGRESQL?
- Open-source relational database.
- ACID transactions (Atomic, Consistent, Isolated, Durable).
- Critical for financial applications to ensure data integrity.



INSTALLATION:
✓ PostgreSQL 16 installed.
✓ pgAdmin 4 for GUI management.
✓ Database created: expense_tracker_db.
✓ User: postgres, Password: postgres123 (dev only).

SPRING BOOT CONNECTION:
- Added dependencies: postgresql driver & spring-boot-starter-data-jpa.
- Configuration in application.properties:
  * URL: jdbc:postgresql://localhost:5432/expense_tracker_db
  * ddl-auto: update (set to automatically sync schema once entities are defined).
  * show-sql: true (to monitor Hibernate's upcoming generation).

ORM (Object-Relational Mapping):
- Hibernate = The engine that maps Java Objects ↔ Database Tables.
- Current Status: The bridge is built (Connection), but no traffic is flowing (No Entities).

WHAT HAPPENED (TODAY'S PROGRESS):
1. Successfully installed the PostgreSQL database engine.
2. Created the physical 'expense_tracker_db' container.
3. Established a "handshake" between Spring Boot and the Database.
4. Verified that the app starts without "Connection Refused" errors.



NOTE ON TABLE GENERATION:
- The 'transaction' table does NOT exist yet. 
- Hibernate requires the @Entity annotation to recognize a class as a database table.
- Currently, the database is empty, awaiting tomorrow's mapping.

ARCHITECTURE EVOLUTION:
- Week 1: Pure Java (Logic only).
- Week 2: In-memory (ArrayList).
- Week 3: Infrastructure Ready (PostgreSQL connected).

ACID PROPERTIES (Fintech Focus):
- Atomicity: "All or nothing" (e.g., Money leaves A AND arrives at B).
- Consistency: No illegal data states.
- Isolation: Transactions don't "bump" into each other.
- Durability: Once saved, it's permanent.

TESTING COMPLETED:
✓ PostgreSQL engine is running.
✓ pgAdmin connects to 'Local PostgreSQL'.
✓ Spring Boot console shows "Connected to: PostgreSQL 16".
✓ NO connection timeout/authentication errors.

NEXT STEPS:
- Day 2: Convert Transaction.java to a JPA Entity (The magic moment).
- Day 3: Create Repository (The database query tool).

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 2 - JPA ENTITIES
Tuesday Feb 17, 2026
═══════════════════════════════════════════════════════════

WHAT IS JPA?
Java Persistence API - standard for Object-Relational Mapping (ORM)
Maps Java objects ↔ Database tables automatically
No manual SQL needed for CRUD operations

HIBERNATE:
JPA implementation (like ArrayList implements List)
Generates SQL based on entity annotations
Manages entity lifecycle (transient → persistent → detached)

KEY JPA ANNOTATIONS:
@Entity - marks class as database table
@Table(name = "...") - customizes table name
@Id - marks primary key field (REQUIRED - one per entity)
@Column(name = "...") - customizes column properties
@PrePersist - lifecycle callback before insert
@PostPersist - lifecycle callback after insert
@PreUpdate - lifecycle callback before update
@PostUpdate - lifecycle callback after update

@Column ATTRIBUTES:
name: database column name
nullable: true/false (NULL/NOT NULL constraint)
length: for VARCHAR types (e.g., VARCHAR(50))
precision: total digits for NUMERIC types
scale: decimal places for NUMERIC types
unique: true/false (UNIQUE constraint)
updatable: true/false (can be updated after creation)

ENTITY REQUIREMENTS:
1. Must have @Entity annotation
2. Must have @Id field (primary key)
3. Must have no-arg constructor (can be protected/private)
4. Class cannot be final
5. Fields should not be final (JPA needs to modify them)

JAVA → SQL NAMING CONVENTION:
Java: camelCase (fromAccount, toAccount)
SQL: snake_case (from_account, to_account)
Hibernate converts automatically, but @Column(name = "...") is explicit

JAVA TYPE → SQL TYPE MAPPING (PostgreSQL):
String → VARCHAR
BigDecimal → NUMERIC
LocalDateTime → TIMESTAMP
Integer → INTEGER
Long → BIGINT
Boolean → BOOLEAN
Enum → VARCHAR (by default) or INTEGER

LIFECYCLE CALLBACKS:
@PrePersist: runs before INSERT
@PostPersist: runs after INSERT
@PreUpdate: runs before UPDATE
@PostUpdate: runs after UPDATE
@PreRemove: runs before DELETE
@PostRemove: runs after DELETE

Use case: Set timestamps, generate IDs, validate data, audit logging

WHAT WE DID TODAY:
1. Added JPA annotations to Transaction class
2. Defined table name: @Table(name = "transactions")
3. Marked primary key: @Id on transactionId
4. Customized columns: @Column with name, nullable, length, precision
5. Added lifecycle hook: @PrePersist to set defaults
6. Restarted app → Hibernate recreated table with correct structure
7. Practiced SQL queries in psql

SQL COMMANDS PRACTICED:
INSERT INTO transactions (...) VALUES (...);
SELECT * FROM transactions;
SELECT * FROM transactions WHERE from_account = '001';
SELECT COUNT(*), SUM(amount), AVG(amount) FROM transactions;
SELECT from_account, COUNT(*) FROM transactions GROUP BY from_account;
UPDATE transactions SET status = 'refunded' WHERE transaction_id = 'TX0001';
DELETE FROM transactions WHERE transaction_id = 'TX0001';

TABLE STRUCTURE VERIFICATION:
\d transactions (in psql) - shows columns, types, constraints
pgAdmin → Tables → transactions → Properties → Columns

TOMORROW: Create Repository interface (JpaRepository)
No more manual SQL! Repository provides CRUD methods automatically.

═══════════════════════════════════════════════════════════