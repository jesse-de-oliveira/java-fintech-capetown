═══════════════════════════════════════════════════════════
WEEK 3 - DAY 1 - POSTGRESQL SETUP + CONNECTION
Monday Feb 16, 2026
═══════════════════════════════════════════════════════════

WHY DATABASES?
- In-memory storage (Week 2): Data lost on restart.
- Database storage (Week 3): Data persists forever.

WHAT IS POSTGRESQL?
- Open-source relational database.
- ACID transactions (Atomic, Consistent, Isolated, Durable).
- Critical for financial applications to ensure data integrity.



INSTALLATION:
✓ PostgreSQL 16 installed.
✓ pgAdmin 4 for GUI management.
✓ Database created: expense_tracker_db.
✓ User: postgres, Password: postgres123 (dev only).

SPRING BOOT CONNECTION:
- Added dependencies: postgresql driver & spring-boot-starter-data-jpa.
- Configuration in application.properties:
  * URL: jdbc:postgresql://localhost:5432/expense_tracker_db
  * ddl-auto: update (set to automatically sync schema once entities are defined).
  * show-sql: true (to monitor Hibernate's upcoming generation).

ORM (Object-Relational Mapping):
- Hibernate = The engine that maps Java Objects ↔ Database Tables.
- Current Status: The bridge is built (Connection), but no traffic is flowing (No Entities).

WHAT HAPPENED (TODAY'S PROGRESS):
1. Successfully installed the PostgreSQL database engine.
2. Created the physical 'expense_tracker_db' container.
3. Established a "handshake" between Spring Boot and the Database.
4. Verified that the app starts without "Connection Refused" errors.



NOTE ON TABLE GENERATION:
- The 'transaction' table does NOT exist yet. 
- Hibernate requires the @Entity annotation to recognize a class as a database table.
- Currently, the database is empty, awaiting tomorrow's mapping.

ARCHITECTURE EVOLUTION:
- Week 1: Pure Java (Logic only).
- Week 2: In-memory (ArrayList).
- Week 3: Infrastructure Ready (PostgreSQL connected).

ACID PROPERTIES (Fintech Focus):
- Atomicity: "All or nothing" (e.g., Money leaves A AND arrives at B).
- Consistency: No illegal data states.
- Isolation: Transactions don't "bump" into each other.
- Durability: Once saved, it's permanent.

TESTING COMPLETED:
✓ PostgreSQL engine is running.
✓ pgAdmin connects to 'Local PostgreSQL'.
✓ Spring Boot console shows "Connected to: PostgreSQL 16".
✓ NO connection timeout/authentication errors.

NEXT STEPS:
- Day 2: Convert Transaction.java to a JPA Entity (The magic moment).
- Day 3: Create Repository (The database query tool).

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 2 - JPA ENTITIES
Tuesday Feb 17, 2026
═══════════════════════════════════════════════════════════

WHAT IS JPA?
Java Persistence API - standard for Object-Relational Mapping (ORM)
Maps Java objects ↔ Database tables automatically
No manual SQL needed for CRUD operations

HIBERNATE:
JPA implementation (like ArrayList implements List)
Generates SQL based on entity annotations
Manages entity lifecycle (transient → persistent → detached)

KEY JPA ANNOTATIONS:
@Entity - marks class as database table
@Table(name = "...") - customizes table name
@Id - marks primary key field (REQUIRED - one per entity)
@Column(name = "...") - customizes column properties
@PrePersist - lifecycle callback before insert
@PostPersist - lifecycle callback after insert
@PreUpdate - lifecycle callback before update
@PostUpdate - lifecycle callback after update

@Column ATTRIBUTES:
name: database column name
nullable: true/false (NULL/NOT NULL constraint)
length: for VARCHAR types (e.g., VARCHAR(50))
precision: total digits for NUMERIC types
scale: decimal places for NUMERIC types
unique: true/false (UNIQUE constraint)
updatable: true/false (can be updated after creation)

ENTITY REQUIREMENTS:
1. Must have @Entity annotation
2. Must have @Id field (primary key)
3. Must have no-arg constructor (can be protected/private)
4. Class cannot be final
5. Fields should not be final (JPA needs to modify them)

JAVA → SQL NAMING CONVENTION:
Java: camelCase (fromAccount, toAccount)
SQL: snake_case (from_account, to_account)
Hibernate converts automatically, but @Column(name = "...") is explicit

JAVA TYPE → SQL TYPE MAPPING (PostgreSQL):
String → VARCHAR
BigDecimal → NUMERIC
LocalDateTime → TIMESTAMP
Integer → INTEGER
Long → BIGINT
Boolean → BOOLEAN
Enum → VARCHAR (by default) or INTEGER

LIFECYCLE CALLBACKS:
@PrePersist: runs before INSERT
@PostPersist: runs after INSERT
@PreUpdate: runs before UPDATE
@PostUpdate: runs after UPDATE
@PreRemove: runs before DELETE
@PostRemove: runs after DELETE

Use case: Set timestamps, generate IDs, validate data, audit logging

WHAT WE DID TODAY:
1. Added JPA annotations to Transaction class
2. Defined table name: @Table(name = "transactions")
3. Marked primary key: @Id on transactionId
4. Customized columns: @Column with name, nullable, length, precision
5. Added lifecycle hook: @PrePersist to set defaults
6. Restarted app → Hibernate recreated table with correct structure
7. Practiced SQL queries in psql

SQL COMMANDS PRACTICED:
INSERT INTO transactions (...) VALUES (...);
SELECT * FROM transactions;
SELECT * FROM transactions WHERE from_account = '001';
SELECT COUNT(*), SUM(amount), AVG(amount) FROM transactions;
SELECT from_account, COUNT(*) FROM transactions GROUP BY from_account;
UPDATE transactions SET status = 'refunded' WHERE transaction_id = 'TX0001';
DELETE FROM transactions WHERE transaction_id = 'TX0001';

TABLE STRUCTURE VERIFICATION:
\d transactions (in psql) - shows columns, types, constraints
pgAdmin → Tables → transactions → Properties → Columns

TOMORROW: Create Repository interface (JpaRepository)
No more manual SQL! Repository provides CRUD methods automatically.

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 3 - REPOSITORY LAYER
Wednesday Feb 18, 2026
═══════════════════════════════════════════════════════════

REPOSITORY PATTERN:
Interface between domain objects and database
Separates data access logic from business logic
Allows easy testing (mock repositories)

WHY REPOSITORIES?
Before: Controller directly accesses database (bad!)
After: Controller → Repository → Database (clean architecture)

Controller: HTTP handling only
Repository: Database operations only
Each layer has ONE responsibility

JPAREPOSITORY:
Spring Data JPA interface providing CRUD methods
Extend JpaRepository<Entity, PrimaryKeyType>
No implementation needed - Spring creates it at runtime!

Built-in methods (FREE, no code):
- save(entity) - insert or update
- findById(id) - find by primary key
- findAll() - get all records
- deleteById(id) - delete by ID
- count() - count total records
- existsById(id) - check if exists

CUSTOM QUERY METHODS:
Spring generates SQL from method names automatically!

Method naming convention:
findBy + Field + Operator

Examples:
findByFromAccount(String account)
→ WHERE from_account = ?

findByAmountGreaterThan(BigDecimal amount)
→ WHERE amount > ?

findByFromAccountAndStatus(String account, String status)
→ WHERE from_account = ? AND status = ?

findByFromAccountOrToAccount(String from, String to)
→ WHERE from_account = ? OR to_account = ?

Keywords:
- findBy, getBy, queryBy, readBy
- And, Or
- GreaterThan, LessThan, Between
- Like, Containing, StartingWith, EndingWith
- OrderBy, OrderByDesc
- Top, First

OPTIONAL<T>:
Container that may or may not have a value
Used when database query might return nothing

Usage:
Optional<Transaction> result = repository.findById("TX001");

// Get value or throw exception
Transaction tx = result.orElseThrow(() -> new ResourceNotFoundException(...));

// Get value or return default
Transaction tx = result.orElse(new Transaction());

// Check if present
if (result.isPresent()) { ... }

WHY OPTIONAL?
Prevents NullPointerException
Forces handling of "not found" case
Makes code more explicit about missing data

CONTROLLER CHANGES:
Before: private List<Transaction> transactions = new ArrayList<>();
After: @Autowired private TransactionRepository transactionRepository;

save() replaces transactions.add()
findById() replaces stream().filter()
findAll() replaces transactions
delete() replaces transactions.remove()

@AUTOWIRED:
Dependency Injection annotation
Spring automatically creates TransactionRepository instance
Injects it into controller when app starts

TESTING COMPLETED:
✓ Created transaction (saved to database)
✓ Restarted app (data persisted!)
✓ Retrieved transactions (read from database)
✓ Filtered by account (custom query method)
✓ Filtered by status (custom query method)
✓ Combined filters (multiple parameters)
✓ Large transactions query (amount threshold)

SQL GENERATION:
Hibernate logs SQL in console (show-sql: true)
Can see exact queries generated from method names
Example:
findByFromAccountOrToAccount(account, account)
→ SELECT * FROM transactions WHERE from_account = ? OR to_account = ?

KEY ACHIEVEMENT:
DATA NOW PERSISTS ACROSS APPLICATION RESTARTS!
Before: Stop app → data lost
Now: Stop app → restart → data still there ✓

ARCHITECTURE LAYERS:
1. Controller Layer: HTTP handling (@RestController)
2. Repository Layer: Data access (JpaRepository)
3. ORM Layer: Object mapping (Hibernate)
4. Database Layer: Storage (PostgreSQL)

Clean separation of concerns!

TOMORROW: Service layer (business logic between Controller and Repository)
Move business rules from Controller to Service
Controller → Service → Repository → Database

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 4 - SERVICE LAYER + SQL DEEP DIVE
Thursday Feb 20-23, 2026
═══════════════════════════════════════════════════════════

SERVICE LAYER PATTERN:
Business logic layer between Controller and Repository
Separates concerns: HTTP handling vs business rules vs data access

3-TIER ARCHITECTURE:
Controller → Service → Repository → Database

Controller: HTTP requests/responses only
Service: Business logic, validation, orchestration
Repository: Database queries only

WHY SERVICE LAYER?
1. Separation of concerns (each layer has ONE job)
2. Reusability (multiple controllers can use same service)
3. Testability (test business logic without HTTP)
4. Transaction management (@Transactional)

@SERVICE ANNOTATION:
Marks class as service component
Spring creates singleton instance
Can be autowired into controllers

@TRANSACTIONAL:
Ensures database operations are atomic (all-or-nothing)
If any operation fails, all rollback
Critical for financial transactions

CONTROLLER CHANGES:
Before: Controller had business logic + repository calls
After: Controller delegates to service, only handles HTTP

Example:
Before: if (tx.getFromAccount().equals(tx.getToAccount())) { throw... }
After: transactionService.createTransaction(tx); // Service handles validation

REFACTORING COMPLETED:
Moved business logic from Controller to Service:
- Account validation (cannot transfer to same account)
- ID generation (TX0001, TX0002...)
- Status validation (cannot change refunded transactions)
- Default value setting (currency, timestamp)

Controller now THIN (only HTTP handling)
Service now contains ALL business rules

SQL DEEP DIVE (30 MIN PRACTICE):

BASIC QUERIES:
SELECT * FROM transactions;
SELECT column1, column2 FROM table;
WHERE clause filters rows
ORDER BY sorts results

AGGREGATIONS:
COUNT(*) - count rows
SUM(amount) - total
AVG(amount) - average
MIN(amount) - smallest
MAX(amount) - largest

GROUP BY:
Groups rows by column value
Must aggregate other columns
Example: SELECT from_account, COUNT(*) FROM transactions GROUP BY from_account;

HAVING:
Filters groups (after GROUP BY)
WHERE filters rows (before GROUP BY)
Example: HAVING SUM(amount) > 1000

SUBQUERIES:
Query inside another query
Can be in WHERE, FROM, or SELECT clause
Example: WHERE amount > (SELECT AVG(amount) FROM transactions)

INTERVIEW SQL PATTERNS:
1. Aggregations with GROUP BY
2. Filtering with HAVING
3. Subqueries for complex conditions
4. Second highest/Nth value queries
5. Combining data with JOINs (advanced, not needed yet)

SQL KEYWORDS PRACTICED:
SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY
COUNT, SUM, AVG, MIN, MAX
AND, OR, IN
LIMIT, OFFSET
DISTINCT, UNION

CRITICAL ACHIEVEMENT:
Clean 3-tier architecture complete!
Controller → Service → Repository separation working
All business logic centralized in Service layer

ARCHITECTURE BENEFITS:
1. Easy to test (mock service in controller tests)
2. Easy to reuse (multiple controllers use same service)
3. Easy to maintain (business rules in one place)
4. Professional pattern (used in all production systems)

TOMORROW: Complete integration, verify persistence, indexing

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 5 - COMPLETE INTEGRATION + INDEXING
Monday Feb 24, 2026
═══════════════════════════════════════════════════════════

WEEK 3 SUMMARY:
Day 1: PostgreSQL setup + connection
Day 2: JPA entity annotations
Day 3: Repository layer (JpaRepository)
Day 4: Service layer (3-tier architecture)
Day 5: Complete integration + optimization (TODAY)

CRITICAL FIX: ID GENERATION
Problem: In-memory counter reset on restart (duplicate IDs)
Solution: Generate ID from database (find max, increment)

Before: private int counter = 1; // Resets every restart
After: Query database, find highest ID, increment

This ensures:
- TX0001, TX0002, TX0003 (first run)
- Stop app, restart
- TX0004, TX0005... (sequence continues!)

PERSISTENCE VERIFICATION:
✓ Created transactions
✓ Stopped application
✓ Restarted application
✓ Data still present (not lost!)
✓ ID sequence continues correctly
✓ All endpoints work with database

CRITICAL ACHIEVEMENT: DATA PERSISTS FOREVER
Before Week 3: Data lost on restart (in-memory ArrayList)
After Week 3: Data survives restarts (PostgreSQL database)

DATABASE INDEXING:
Index = Data structure speeding up queries
Like book table of contents (jump to page vs read every page)

Indexes created:
idx_from_account - speeds up: WHERE from_account = ?
idx_to_account - speeds up: WHERE to_account = ?
idx_status - speeds up: WHERE status = ?
idx_timestamp - speeds up: ORDER BY timestamp
idx_account_status - composite for: WHERE from_account = ? AND status = ?

WHEN TO INDEX:
✓ Primary keys (automatic)
✓ Foreign keys
✓ Columns in WHERE clauses
✓ Columns in JOIN conditions
✓ Columns in ORDER BY

PERFORMANCE IMPACT:
Sequential Scan: Reads ALL rows (slow for large tables)
Index Scan: Reads ONLY matching rows (10-100x faster!)

Example:
1000 rows, query: WHERE from_account = 'ACC050'
Without index: Read 1000 rows
With index: Read 10-20 rows

EXPLAIN ANALYZE:
SQL command showing how query executes
Shows: Seq Scan (slow) vs Index Scan (fast)

Usage:
EXPLAIN ANALYZE SELECT * FROM transactions WHERE from_account = '001';

Look for:
- "Seq Scan" = No index used (slow)
- "Index Scan" = Index used (fast)
- "cost" = Relative expense
- "rows" = Estimated rows

INDEX TRADEOFFS:
Pros:
- Faster reads (10-100x)
- Critical for large tables
- Production requirement

Cons:
- Slower writes (must update index)
- Uses disk space
- Too many indexes = diminishing returns

Rule: Index columns you QUERY often, not columns you WRITE often

WEEK 3 COMPLETE:
✓ PostgreSQL installed and configured
✓ JPA entities with proper annotations
✓ Repository layer with custom queries
✓ Service layer with business logic
✓ 3-tier architecture (Controller → Service → Repository)
✓ Data persistence across restarts
✓ Database indexes for performance
✓ Production-grade architecture

FINAL ARCHITECTURE:
HTTP Request
    ↓
Controller (HTTP handling)
    ↓
Service (Business logic)
    ↓
Repository (Data access)
    ↓
Hibernate (ORM layer)
    ↓
PostgreSQL (Database + Indexes)

NEXT WEEK: AWS deployment (EC2, RDS, public URL)

═══════════════════════════════════════════════════════════
