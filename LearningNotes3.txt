═══════════════════════════════════════════════════════════
WEEK 3 - DAY 1 - POSTGRESQL SETUP + CONNECTION
Monday Feb 16, 2026
═══════════════════════════════════════════════════════════

WHY DATABASES?
- In-memory storage (Week 2): Data lost on restart.
- Database storage (Week 3): Data persists forever.

WHAT IS POSTGRESQL?
- Open-source relational database.
- ACID transactions (Atomic, Consistent, Isolated, Durable).
- Critical for financial applications to ensure data integrity.



INSTALLATION:
✓ PostgreSQL 16 installed.
✓ pgAdmin 4 for GUI management.
✓ Database created: expense_tracker_db.
✓ User: postgres, Password: postgres123 (dev only).

SPRING BOOT CONNECTION:
- Added dependencies: postgresql driver & spring-boot-starter-data-jpa.
- Configuration in application.properties:
  * URL: jdbc:postgresql://localhost:5432/expense_tracker_db
  * ddl-auto: update (set to automatically sync schema once entities are defined).
  * show-sql: true (to monitor Hibernate's upcoming generation).

ORM (Object-Relational Mapping):
- Hibernate = The engine that maps Java Objects ↔ Database Tables.
- Current Status: The bridge is built (Connection), but no traffic is flowing (No Entities).

WHAT HAPPENED (TODAY'S PROGRESS):
1. Successfully installed the PostgreSQL database engine.
2. Created the physical 'expense_tracker_db' container.
3. Established a "handshake" between Spring Boot and the Database.
4. Verified that the app starts without "Connection Refused" errors.



NOTE ON TABLE GENERATION:
- The 'transaction' table does NOT exist yet. 
- Hibernate requires the @Entity annotation to recognize a class as a database table.
- Currently, the database is empty, awaiting tomorrow's mapping.

ARCHITECTURE EVOLUTION:
- Week 1: Pure Java (Logic only).
- Week 2: In-memory (ArrayList).
- Week 3: Infrastructure Ready (PostgreSQL connected).

ACID PROPERTIES (Fintech Focus):
- Atomicity: "All or nothing" (e.g., Money leaves A AND arrives at B).
- Consistency: No illegal data states.
- Isolation: Transactions don't "bump" into each other.
- Durability: Once saved, it's permanent.

TESTING COMPLETED:
✓ PostgreSQL engine is running.
✓ pgAdmin connects to 'Local PostgreSQL'.
✓ Spring Boot console shows "Connected to: PostgreSQL 16".
✓ NO connection timeout/authentication errors.

NEXT STEPS:
- Day 2: Convert Transaction.java to a JPA Entity (The magic moment).
- Day 3: Create Repository (The database query tool).

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 2 - JPA ENTITIES
Tuesday Feb 17, 2026
═══════════════════════════════════════════════════════════

WHAT IS JPA?
Java Persistence API - standard for Object-Relational Mapping (ORM)
Maps Java objects ↔ Database tables automatically
No manual SQL needed for CRUD operations

HIBERNATE:
JPA implementation (like ArrayList implements List)
Generates SQL based on entity annotations
Manages entity lifecycle (transient → persistent → detached)

KEY JPA ANNOTATIONS:
@Entity - marks class as database table
@Table(name = "...") - customizes table name
@Id - marks primary key field (REQUIRED - one per entity)
@Column(name = "...") - customizes column properties
@PrePersist - lifecycle callback before insert
@PostPersist - lifecycle callback after insert
@PreUpdate - lifecycle callback before update
@PostUpdate - lifecycle callback after update

@Column ATTRIBUTES:
name: database column name
nullable: true/false (NULL/NOT NULL constraint)
length: for VARCHAR types (e.g., VARCHAR(50))
precision: total digits for NUMERIC types
scale: decimal places for NUMERIC types
unique: true/false (UNIQUE constraint)
updatable: true/false (can be updated after creation)

ENTITY REQUIREMENTS:
1. Must have @Entity annotation
2. Must have @Id field (primary key)
3. Must have no-arg constructor (can be protected/private)
4. Class cannot be final
5. Fields should not be final (JPA needs to modify them)

JAVA → SQL NAMING CONVENTION:
Java: camelCase (fromAccount, toAccount)
SQL: snake_case (from_account, to_account)
Hibernate converts automatically, but @Column(name = "...") is explicit

JAVA TYPE → SQL TYPE MAPPING (PostgreSQL):
String → VARCHAR
BigDecimal → NUMERIC
LocalDateTime → TIMESTAMP
Integer → INTEGER
Long → BIGINT
Boolean → BOOLEAN
Enum → VARCHAR (by default) or INTEGER

LIFECYCLE CALLBACKS:
@PrePersist: runs before INSERT
@PostPersist: runs after INSERT
@PreUpdate: runs before UPDATE
@PostUpdate: runs after UPDATE
@PreRemove: runs before DELETE
@PostRemove: runs after DELETE

Use case: Set timestamps, generate IDs, validate data, audit logging

WHAT WE DID TODAY:
1. Added JPA annotations to Transaction class
2. Defined table name: @Table(name = "transactions")
3. Marked primary key: @Id on transactionId
4. Customized columns: @Column with name, nullable, length, precision
5. Added lifecycle hook: @PrePersist to set defaults
6. Restarted app → Hibernate recreated table with correct structure
7. Practiced SQL queries in psql

SQL COMMANDS PRACTICED:
INSERT INTO transactions (...) VALUES (...);
SELECT * FROM transactions;
SELECT * FROM transactions WHERE from_account = '001';
SELECT COUNT(*), SUM(amount), AVG(amount) FROM transactions;
SELECT from_account, COUNT(*) FROM transactions GROUP BY from_account;
UPDATE transactions SET status = 'refunded' WHERE transaction_id = 'TX0001';
DELETE FROM transactions WHERE transaction_id = 'TX0001';

TABLE STRUCTURE VERIFICATION:
\d transactions (in psql) - shows columns, types, constraints
pgAdmin → Tables → transactions → Properties → Columns

TOMORROW: Create Repository interface (JpaRepository)
No more manual SQL! Repository provides CRUD methods automatically.

═══════════════════════════════════════════════════════════
WEEK 3 - DAY 3 - REPOSITORY LAYER
Wednesday Feb 18, 2026
═══════════════════════════════════════════════════════════

REPOSITORY PATTERN:
Interface between domain objects and database
Separates data access logic from business logic
Allows easy testing (mock repositories)

WHY REPOSITORIES?
Before: Controller directly accesses database (bad!)
After: Controller → Repository → Database (clean architecture)

Controller: HTTP handling only
Repository: Database operations only
Each layer has ONE responsibility

JPAREPOSITORY:
Spring Data JPA interface providing CRUD methods
Extend JpaRepository<Entity, PrimaryKeyType>
No implementation needed - Spring creates it at runtime!

Built-in methods (FREE, no code):
- save(entity) - insert or update
- findById(id) - find by primary key
- findAll() - get all records
- deleteById(id) - delete by ID
- count() - count total records
- existsById(id) - check if exists

CUSTOM QUERY METHODS:
Spring generates SQL from method names automatically!

Method naming convention:
findBy + Field + Operator

Examples:
findByFromAccount(String account)
→ WHERE from_account = ?

findByAmountGreaterThan(BigDecimal amount)
→ WHERE amount > ?

findByFromAccountAndStatus(String account, String status)
→ WHERE from_account = ? AND status = ?

findByFromAccountOrToAccount(String from, String to)
→ WHERE from_account = ? OR to_account = ?

Keywords:
- findBy, getBy, queryBy, readBy
- And, Or
- GreaterThan, LessThan, Between
- Like, Containing, StartingWith, EndingWith
- OrderBy, OrderByDesc
- Top, First

OPTIONAL<T>:
Container that may or may not have a value
Used when database query might return nothing

Usage:
Optional<Transaction> result = repository.findById("TX001");

// Get value or throw exception
Transaction tx = result.orElseThrow(() -> new ResourceNotFoundException(...));

// Get value or return default
Transaction tx = result.orElse(new Transaction());

// Check if present
if (result.isPresent()) { ... }

WHY OPTIONAL?
Prevents NullPointerException
Forces handling of "not found" case
Makes code more explicit about missing data

CONTROLLER CHANGES:
Before: private List<Transaction> transactions = new ArrayList<>();
After: @Autowired private TransactionRepository transactionRepository;

save() replaces transactions.add()
findById() replaces stream().filter()
findAll() replaces transactions
delete() replaces transactions.remove()

@AUTOWIRED:
Dependency Injection annotation
Spring automatically creates TransactionRepository instance
Injects it into controller when app starts

TESTING COMPLETED:
✓ Created transaction (saved to database)
✓ Restarted app (data persisted!)
✓ Retrieved transactions (read from database)
✓ Filtered by account (custom query method)
✓ Filtered by status (custom query method)
✓ Combined filters (multiple parameters)
✓ Large transactions query (amount threshold)

SQL GENERATION:
Hibernate logs SQL in console (show-sql: true)
Can see exact queries generated from method names
Example:
findByFromAccountOrToAccount(account, account)
→ SELECT * FROM transactions WHERE from_account = ? OR to_account = ?

KEY ACHIEVEMENT:
DATA NOW PERSISTS ACROSS APPLICATION RESTARTS!
Before: Stop app → data lost
Now: Stop app → restart → data still there ✓

ARCHITECTURE LAYERS:
1. Controller Layer: HTTP handling (@RestController)
2. Repository Layer: Data access (JpaRepository)
3. ORM Layer: Object mapping (Hibernate)
4. Database Layer: Storage (PostgreSQL)

Clean separation of concerns!

TOMORROW: Service layer (business logic between Controller and Repository)
Move business rules from Controller to Service
Controller → Service → Repository → Database