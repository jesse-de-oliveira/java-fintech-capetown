///////////////////////////////////////////
ğŸ¯ UPDATED: WEEK 0 - FINTECH FOUNDATIONS
///////////////////////////////////////////

//////////////////////////////////////////////////
DAY 1 - Why BigDecimal? & The SA Tax Context (VAT)
Date: Tuesday, Jan 27, 2026
//////////////////////////////////////////////////


Question: Why can't we use double for currency?
Answer: double uses binary floating-point math. It cannot represent base-10 decimals (like 0.1) exactly.
	-Problem: 0.1 + 0.2 = 0.30000000000000004
	-Risk: In South African banking, rounding errors on millions of transactions lead to massive financial discrepancies and compliance failure with the South African Reserve Bank (SARB)

Technical Goal: ZAR Tax Calculator
In South Africa, the primary tax for financial calculations is VAT (Value Added Tax).
	-Current Rate: 15%
	-Rule: Always use the String constructor for BigDecimal: new BigDecimal("15.00").
	
Implementation Logic:
	1.Capture transaction amount.
	2.Define transaction type (Standard, Exempt, or Zero-rated).
	3.Apply 15% VAT for Standard items.
	4.Output the Net and Gross amounts in ZAR (R).
	
What I Learned Today:
	-double is dangerous for ZAR transactions due to precision loss.
	-BigDecimal methods: .add(), .subtract(), .multiply(), and .divide(amount, 2, RoundingMode.HALF_UP).
	-South African VAT is 15%. I updated my code to reflect the local economy instead of Brazilian IOF.
	
/////////////////////////////////////////////////////////////
DAY 2 - Collections: ArrayList & HashMap (Account Management)
Date: Wednesday, Jan 28, 2026
/////////////////////////////////////////////////////////////

Question: What is an ArrayList and why use it for transaction history?
Answer: It is a resizable (dynamic) array. Standard arrays in Java are static; an ArrayList grows as a customer makes more transactions.

Key Methods: .add(), .get(), .size().
ZAR Syntax Note: Always use .compareTo() for BigDecimal.
	-balance.compareTo(withdrawal) >= 0 (Can I afford this?)
	
The "Bank Dictionary" (HashMap):
I used a HashMap<String, BigDecimal> to simulate a bankâ€™s ledger.
	-Key: Account Number (e.g., "786001234")
	-Value: Balance (e.g., R5500.50)	
	
Project Update: PayShap Pre-requisite
I built a system that:
	-Stores multiple accounts.
	-Checks balance using a key (Account Number).
	-Executes Deposits and Withdrawals safely.
	-Lists all accounts in the "Bank."
	
Summary for LinkedIn/Recruiters:
"Today I mastered Java Collections within a Fintech context. I implemented a dynamic transaction ledger using ArrayList and a high-performance account look-up system using HashMap. I ensured all financial logic remains precise by wrapping these collections with BigDecimal and handled ZAR comparisons using .compareTo() to avoid the pitfalls of floating-point math."


/////////////////////////////////////////////////////////////
DAY 3 - OBJECT-ORIENTED PROGRAMMING (OOP)
Date: Wednesday, Jan 29/30, 2026
/////////////////////////////////////////////////////////////

What is it? It is a programming paradigm that organizes code around "objects" which bundle:
	1.Data (fields/attributes)
	2.Behaviour (methods) 
	
Example from real life:
	-A "bank account" is an object
	-It has data: balance, account number, owner name
	-It has behaviour: deposit(), withdraw(), getBalance()
	
The 4 pillars of OOP:

1.ENCAPSULATION (Today's focus)
  Definition: Hide internal details, expose only what's needed
  
  Why it matters:
  -Protects data from accidental modification
  -Enforces business rules (e.g. "can't have negative balance")
  -Changes to internals don't break external code
  
  Implementation:
  -Make fields private
  -Provide public getters (read access)
  -Provide limited setters (controlled write access)
  -Validate inputs in constructors/setters
  
  Example:
  public class BankAccount {
  	private BigDecimal balance;  // Hidden from outside
  	
  	public BigDecimal getBalance() {  // Safe read access
  	return balance;
  	}
  public void deposit(BigDecimal amount) {  // Controlled write
  	if (amount.compareTo(BigDEcimal.ZERO) <= 0) {
  	throw new IllegalArgumentException("Amount must be positive");
  	}
  	this.balance = this.balance.add(amount);
  	
  	//NO setBalance() method - balance only changes via deposit / withdraw
  	
  }
  
  Interview Answer:
  "Encapsulation bundles data and methods while hiding internals.
   In my Transaction class, I made amount and accountNumber private 
   to prevent external code from creating invalid states like negative amounts. 
   Public getters allow safe read access."
  
2.INHERITANCE (will learn in week 3)
  Definition: Create new classes based on existing ones
  Example: SavingsAccount extends BankAccount
  Benefit: Code reuse
  
3.POLYMORPHISM (will learn in week 4)
  Definition: Same method name, different behaviours
  Example: withdraw() works differently for different account types
  
4.ABSTRACTION (will learn in week 4)
  Definition: Hide complexity, show only essentials
  Example: You use withdraw() without knowing TCP/IP protocols
  
 Why OOP for Cape Town Fintech:
 
 1. Industry standard:
 	-Every company uses OOP
 	-Java is inherently object-oriented
 	-Cannot write professional code without OOP
 	
 2.Interview Questions you WILL get:
 	-"Explain Encapsulation" (they always ask this)
 	-"Why make fields private?"
 	-"Walk me through your transaction class"
 	-"How do you prevent invalid states?"
 	
 3.Real-World Modeling:
 	-Transaction = object (amount, type, timestamp)
 	-Account = object (balance, transactions, owner)
 	-Customer = object (accounts, personal info)
 	
 4.POPIA Compliance (South African data privacy law):
 	-Encapsulation enforces data protection
 	-Can't accidentally expose PII (personal identifiable info)
 	-Access control via methods
  
HOUR 2 & 3 - FLASHCARD FRIDAY:  
 
 Concepts Reviewed:
âœ… BigDecimal (why and how)
âœ… ArrayList vs HashMap (when to use)
âœ… Encapsulation (private fields, public methods)
âœ… Git workflow (add, commit, push)
âœ… SA VAT context (15%, exemptions)


/////////////////////////////////////////////////////////////
DAY 4 - USER INPUT, METHODS, AND ALGORITHMS
Date: Friday, Jan 31, 2026
/////////////////////////////////////////////////////////////
HOUR 1: SCANNER & USER INPUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What is Scanner?
Java class that reads input from keyboard (console input)

Import statement:
import java.util.Scanner;

Creating Scanner object:
Scanner scanner = new Scanner(System.in);
                               â†‘
                          Reads from keyboard
                          
Basic methods:
.nextLine()        -->  Reads entire line as String (for text)
.next()            -->  Reads single word as String  
.nextInt()         -->  Reads integer (whole number)
.nextDouble()      -->  Reads decimal number
.nextBigDecimal()  -->  Reads BigDecimal (for money)

Why Scanner matters:
 - Makes programs interactive
 - Essential for testing (manual testing w/ diff inputs)
 - Real-world apps take user input
 - Interview coding challenges use Scanner
 
 Common Pattern:
	1. Print a question
	2. Read user's answer with Scanner
	3. Validate the input
	4. Use the input in your logic 
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOUR 2: METHODS & FUNCTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What is a method?
A reusable block of code to do something specific.

Why use methods?
1. Organize code (easier to read)
2. Reuse code (don't repeat yourself - DRY principle)
3. Test code (can test each method separately)
4. Interview expectation (shows professional thinking)

Real-world analogy:
Your program = Restaurant
Methods = Kitchen stations (grill station, salad station, dessert station)
Each station does ONE job well
Main method = Head chef coordinating everything

Method Structure:
returnType methodName(parameters) {
	// do something 
	return result;
}

Examples:
- calculateVAT(amount) â†’ returns VAT amount
- validateAge(age) â†’ returns true/false
- formatCurrency(amount) â†’ returns "R 1,234.56"

Methods Key Learnings:

1. Method structure:
   returnType methodName(parameters) {
       // code
       return result;
   }

2. Why methods matter:
   - Organize code
   - Reuse logic (calculateVAT used many times)
   - Easier to test
   - Professional standard

3. Method examples I created:
   - calculateVAT(amount) â†’ returns VAT
   - isValidAmount(amount) â†’ returns boolean
   - formatCurrency(amount) â†’ returns String

4. Interview relevance:
   - Shows I can organize code
   - Breaking problems into functions
   - Writing reusable logic
   
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HOUR 3: BIG-O NOTATION (Algorithm Efficiency)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What is Big-O?
A way to describe how fast or slow an algorithm is.

Why it matters:
- Interviews ALWAYS ask "What's the time complexity?"
- Difference between working code and FAST code
- Critical for fintech (millions of transactions)

The 3 you MUST know:

O(1) - CONSTANT TIME
- Same speed regardless of data size
- Example: HashMap.get(key) - instant lookup
- Best possible performance

O(n) - LINEAR TIME
- Speed grows with data size
- Example: Loop through ArrayList once
- Acceptable for most problems

O(nÂ²) - QUADRATIC TIME (BAD!)
- Speed grows exponentially
- Example: Nested loops
- Avoid this if possible

Real-world analogy:
O(1) = Looking up word in index (page 234)
O(n) = Reading book page by page to find word
O(nÂ²) = Comparing every word to every other word

Interview format:
Interviewer: "What's the time complexity?"
You: "O(n) because I loop through the array once"

Big-O Key Learnings:

1. Three levels I must know:
   O(1) - Constant (HashMap lookup)
   O(n) - Linear (single loop)
   O(nÂ²) - Quadratic (nested loops)

2. Why this matters in interviews:
   - "What's the time complexity?" = always asked
   - Shows I think about performance
   - Difference between junior and senior

3. Real fintech impact:
   - O(1): Process 1 million transactions instantly
   - O(n): Process 1 million transactions in 1 second
   - O(nÂ²): Process 1 million transactions in... never (crashes)

4. Interview answer template:
   "This solution is O(n) because I loop through 
    the array once to find the target."


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WEEK 1 - DAY 2 - Tuesday Feb 3, 2026
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TODAY'S GOAL:
Build Compound Interest Calculator - real financial math

WHY THIS MATTERS:
- Banks use this exact formula for savings accounts
- Interviews often include financial calculations
- Shows I can apply programming to real-world problems
- South African context (FNB, Capitec savings rates)

TYPING STATUS:
- Yesterday: 12.9 WPM
- Still focusing on correct form over speed

FORMULA TO LEARN:
A = P(1 + r/n)^(nt)
Where:
- A = Final amount
- P = Principal (initial investment)
- r = Annual interest rate (as decimal)
- n = Number of times interest compounds per year
- t = Number of years

Simplified (yearly compounding): A = P(1 + r)^t

COMPOUND INTEREST CALCULATOR - KEY LEARNINGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. FINANCIAL MATH MASTERY:
   Formula: A = P(1 + r)^t
   - Implemented year-by-year calculation
   - Showed interest-on-interest growth
   - Used realistic South African bank rates

2. CODE TECHNIQUES:
   - Input validation with while loops
   - Try-catch error handling
   - BigDecimal for precise calculations
   - Scanner for user interaction
   - Professional output formatting

3. REAL-WORLD APPLICATION:
   Example: R 10,000 at 8% for 5 years
   - Simple interest would be: R 4,000 (10k Ã— 8% Ã— 5)
   - Compound interest gives: R 4,693 (R 693 MORE!)
   - That's 17% more money just from compounding

4. PROFESSIONAL TOUCHES:
   - Listed real SA bank rates (FNB, Capitec, TymeBank)
   - Used ZAR currency notation
   - Showed year-by-year breakdown
   - Calculated percentage gain
   - Validated all inputs

5. INTERVIEW RELEVANCE:
   - Shows I can implement financial algorithms
   - Demonstrates input validation skills
   - Clean, professional code structure
   - Real-world problem solving

6. TYPING PROGRESS:
   - Started at 6.8 WPM yesterday
   - Still maintaining correct form
   - Getting more comfortable with no-looking rule

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DAY 3 - LEETCODE TWO SUM
Wednesday Feb 5, 2026
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROBLEM: Find two numbers in array that sum to target

KEY INSIGHT: complement = target - current
- Instead of checking all pairs (slow)
- Ask "have I seen the complement?" (fast)

ALGORITHM:
1. For each number, calculate complement
2. Check if complement in HashMap (O(1))
3. If yes â†’ return indices
4. If no â†’ store current number

COMPLEXITY:
- Time: O(n) - single pass
- Space: O(n) - HashMap storage
- Beats brute force O(nÂ²) by 1000x

INTERVIEW TALKING POINTS:
âœ“ "I'll use a HashMap to track numbers I've seen"
âœ“ "For each number, I calculate its complement"
âœ“ "HashMap lookup is O(1), so total time is O(n)"
âœ“ "This beats the brute force O(nÂ²) approach"

CRITICAL LINE:
int complement = target - nums[i];
if (map.containsKey(complement)) {
    return new int[] {map.get(complement), i};
}

WHY STORE AFTER CHECKING:
- Prevents using same element twice
- Example: nums=[3], target=6
- If we stored first, would return [0,0] âœ—
- Checking first prevents this âœ“

PATTERN RECOGNITION:
This "complement" pattern appears in:
- 3Sum, 4Sum
- Subarray Sum Equals K
- Two Sum II (sorted array)
- 50+ other LeetCode problems

HANDWRITING PRACTICE:
âœ“ Wrote complete solution by hand
âœ“ Traced through 2 examples
âœ“ Wrote 5 test cases
âœ“ Ready for whiteboard interviews

NEXT: HashMap patterns practice (Day 4)




















