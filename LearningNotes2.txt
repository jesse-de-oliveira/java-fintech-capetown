═══════════════════════════════════════════════════════════
WEEK 2 - DAY 1 - SPRING BOOT HELLO WORLD
Monday Feb 9, 2026
═══════════════════════════════════════════════════════════

WHAT IS SPRING BOOT?
Framework that makes building REST APIs easy
- Auto-configuration (sensible defaults)
- Embedded web server (Tomcat)
- Dependency injection (auto-wiring)
- Production-ready features

KEY CONCEPTS:
1. REST API: Client-server communication over HTTP
2. MVC Pattern: Controller (requests) → Service (logic) → Repository (data)
3. Annotations: Metadata for Spring (@RestController, @GetMapping)
4. JSON: Standard data format for APIs

ENDPOINTS BUILT TODAY:
1. GET /hello → Returns plain text
2. GET /balance/{accountId} → Returns JSON account data

ANNOTATIONS LEARNED:
@SpringBootApplication - Main entry point
@RestController - Handles HTTP requests
@GetMapping("/path") - Routes GET requests
@PathVariable - Extracts URL parameter

PROJECT STRUCTURE:
ExpenseTrackerApplication.java - Main file (don't touch)
HelloController.java - Our REST endpoints
pom.xml - Maven dependencies

HOW IT WORKS:
1. Spring Boot starts embedded Tomcat on port 8080
2. Incoming request: GET /balance/001
3. Spring routes to method with @GetMapping("/balance/{accountId}")
4. Method executes, returns Map
5. Spring converts Map → JSON automatically
6. Response sent to client

FINTECH CONTEXT:
This is how TymeBank/Capitec mobile apps communicate with servers!
- App sends: GET /balance/ACC123
- Server responds: {"balance": 5000, "currency": "ZAR"}

WHAT'S DIFFERENT FROM WEEK 1:
- Week 1: Pure Java, all handwritten
- Week 2: Framework, must TYPE to run and test
- Transition: Handwrite logic, type to execute

NEXT: Tuesday - POST requests, accepting JSON input

═══════════════════════════════════════════════════════════
WEEK 2 - DAY 2 - POST REQUESTS + JSON INPUT
Tuesday Feb 10, 2026
═══════════════════════════════════════════════════════════

HTTP METHODS LEARNED:
GET (Day 1): Retrieve data, safe, idempotent
POST (Today): Create data, not safe, not idempotent
PUT (Later): Update existing data
DELETE (Later): Remove data

KEY ANNOTATIONS TODAY:
@PostMapping - Maps HTTP POST requests
@RequestBody - Converts JSON input to Java object
@RequestMapping("/api/transactions") - Base path for controller

WHAT WE BUILT:
1. Transaction model class (POJO with getters/setters)
2. TransactionController with 3 endpoints:
   - POST /api/transactions → Create transaction
   - GET /api/transactions → Get all transactions
   - GET /api/transactions/{id} → Get specific transaction

THE MAGIC: @RequestBody
Spring automatically converts:
JSON → Java Object (deserialization)
Java Object → JSON (serialization)

No manual parsing needed!

TESTING:
Used Postman to send POST requests with JSON body
Can't test POST easily in browser (needs request body)

EXAMPLE POST REQUEST:
URL: http://localhost:8080/api/transactions
Method: POST
Headers: Content-Type: application/json
Body:
{
  "fromAccount": "001",
  "toAccount": "002",
  "amount": 500.00
}

Response:
{
  "transactionId": "TX0001",
  "status": "completed",
  "message": "Transaction created successfully"
}

DATA FLOW:
1. Client sends JSON
2. Spring sees @RequestBody
3. Spring converts JSON → Transaction object
4. Method processes, returns Map
5. Spring converts Map → JSON
6. Client receives JSON response

FINTECH CONTEXT:
This is how TymeBank app creates payments:
- User taps "Send Money"
- App sends POST with transaction details
- Server processes, returns confirmation
- App shows "Payment successful"

CURRENT LIMITATIONS (TO FIX TOMORROW):
- No validation (accepts negative amounts!)
- No account balance checking
- No real database (data lost on restart)
- No error handling for bad input

NEXT: Wednesday - Validation + better error handling

═══════════════════════════════════════════════════════════
WEEK 2 - DAY 3 - VALIDATION + QUERY PARAMETERS
Wednesday Feb 11, 2026
═══════════════════════════════════════════════════════════

TWO LEVELS OF VALIDATION:
1. Bean Validation (annotations on model)
   - @NotBlank - field cannot be empty
   - @NotNull - field cannot be null
   - @Positive - number must be > 0
   - @DecimalMax - maximum value
   - @Size(min, max) - length constraint
   Triggered by: @Valid on @RequestBody parameter

2. Business Logic Validation (manual in code)
   - Custom rules: "Cannot transfer to same account"
   - Domain-specific: "Exceeds daily limit"
   - Written as if-statements in controller/service

KEY ANNOTATIONS:
@Valid - trigger bean validation
@ExceptionHandler - catch validation errors globally
@RequestParam - extract query parameters from URL
ResponseEntity - control HTTP status code

HTTP STATUS CODES (Critical):
200 OK - Success (GET)
201 Created - New resource created (POST)
400 Bad Request - Client sent invalid data
404 Not Found - Resource doesn't exist
500 Internal Server Error - Server crashed

QUERY PARAMETERS:
URL: /api/transactions?account=001&status=completed
Code: @RequestParam(required = false) String account
Use: Filtering, searching, pagination

DIFFERENCE: @PathVariable vs @RequestParam
@PathVariable: /transactions/TX0001 (part of path)
@RequestParam: /transactions?id=TX0001 (after ?)
Use PathVariable for IDs, RequestParam for filters

ResponseEntity examples:
ResponseEntity.ok(body)                    → 200
ResponseEntity.status(CREATED).body(body)  → 201
ResponseEntity.badRequest().body(body)     → 400
ResponseEntity.notFound().build()          → 404

FINTECH CONTEXT:
Validation is critical for:
- Preventing fraud (negative amounts)
- SARB compliance (daily limits)
- POPIA (validating PII format)
- Audit trail integrity

NEXT: Thursday - Error handling + PUT/DELETE

═══════════════════════════════════════════════════════════
WEEK 2 - DAY 4 - ERROR HANDLING + PUT/DELETE
Thursday Feb 12, 2026
═══════════════════════════════════════════════════════════

ERROR HANDLING STRATEGY:
Never expose stack traces to clients (security risk)
Return clean, actionable error messages
Use correct HTTP status codes
Log errors server-side for debugging

CUSTOM EXCEPTIONS CREATED:
ResourceNotFoundException → 404
DuplicateResourceException → 409
InvalidOperationException → 400

GLOBAL EXCEPTION HANDLER:
@RestControllerAdvice applies to ALL controllers
Catches exceptions automatically
Returns consistent error response format

ERROR RESPONSE STRUCTURE:
{
  "timestamp": "2026-02-13T14:30:00",
  "status": 404,
  "error": "Resource Not Found",
  "message": "Transaction not found with id: TX9999"
}

HTTP METHODS COMPLETE:
GET    - Retrieve data (200)
POST   - Create data (201)
PUT    - Update data (200)
DELETE - Remove data (204)

PUT vs PATCH:
PUT: Replace entire resource (or update specific fields)
PATCH: Partial update (we used PUT for status update)
PUT is idempotent (same request = same result)

DELETE CONSIDERATIONS:
204 No Content - success but no response body
Business rules apply (can't delete completed transactions)
In production: Soft delete (mark as deleted, don't remove)

STATUS CODE DECISION TREE:
Success? → 2xx (200, 201, 204)
Client error? → 4xx (400, 404, 409)
Server error? → 5xx (500)

400 vs 409 vs 422:
400: Generic validation error
409: Duplicate resource / conflict
422: Unprocessable entity (valid JSON but business rule fails)

FINTECH CONTEXT:
Mobile apps use status codes to determine user messaging
409 prevents duplicate charges (idempotency)
404 vs 500 determines retry logic
Proper error handling = better UX + fewer support tickets

SECURITY NOTES:
Never return stack traces in production
Generic 500 message protects internal architecture
Log detailed errors server-side only

NEXT: Friday - Complete API + week review


═══════════════════════════════════════════════════════════
WEEK 2 - DAY 5 - POLISH + COMPLETE API
Friday/Saturday Feb 13-14, 2026
═══════════════════════════════════════════════════════════

FINAL FEATURES ADDED:

1. PAGINATION
   - Query params: page, size
   - Default: page=0, size=20
   - Max size: 100 (prevent abuse)
   - Response includes: currentPage, totalPages, isFirst, isLast
   - Prevents loading thousands of records

2. SORTING
   - Query param: sort=field,direction
   - Fields: timestamp, amount, fromAccount
   - Directions: asc, desc
   - Default: timestamp,desc (newest first)
   - Uses Java Comparator

3. STATISTICS ENDPOINT
   - GET /api/transactions/stats
   - Returns: total count, total amount, average, status breakdown
   - Uses Java Streams (map, reduce, groupingBy)

4. BATCH OPERATIONS
   - POST /api/transactions/batch
   - Create multiple transactions at once
   - Returns success/failure counts
   - Use case: CSV import, bulk processing

5. SEARCH
   - GET /api/transactions/search?q=query
   - Case-insensitive description search
   - Returns matching transactions

6. DESCRIPTION FIELD
   - Added to Transaction model
   - Optional, max 200 characters
   - Searchable

COMPLETE API ENDPOINTS:
POST   /api/transactions              - Create single
POST   /api/transactions/batch        - Create multiple
GET    /api/transactions              - List (paginated, sorted, filtered)
GET    /api/transactions/{id}         - Get by ID
GET    /api/transactions/stats        - Statistics
GET    /api/transactions/search?q=X   - Search
PUT    /api/transactions/{id}?status= - Update status
DELETE /api/transactions/{id}         - Delete

QUERY PARAMETERS SUPPORTED:
?account=X      - Filter by account
?status=X       - Filter by status
?page=N         - Page number (0-indexed)
?size=N         - Page size (1-100)
?sort=field,dir - Sort field and direction
?q=X            - Search query

JAVA STREAMS USED:
.filter()       - Filtering
.map()          - Transformation
.reduce()       - Aggregation
.collect()      - Collection
.sorted()       - Sorting
.groupingBy()   - Grouping

PAGINATION MATH:
start = page × size
end = min(start + size, total)
totalPages = ceil(total / size)

PRODUCTION CONSIDERATIONS:
- Pagination prevents memory overflow
- Sorting allows client flexibility
- Statistics useful for dashboards
- Batch operations efficient for imports
- Search enables user-friendly queries

WHAT'S STILL IN-MEMORY:
All data lost on restart (fixed next week with database)

WEEK 2 COMPLETE:
✓ REST API fundamentals
✓ CRUD operations
✓ Validation
✓ Error handling
✓ Pagination
✓ Sorting
✓ Statistics
✓ Batch operations
✓ Search

NEXT WEEK: PostgreSQL database integration